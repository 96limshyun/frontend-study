# 히스토그램에서 최대 직사각형 넓이 구하기

## 문제 설명
히스토그램이 주어졌을 때, 히스토그램 안에서 만들 수 있는 가장 큰 직사각형의 넓이를 구하는 문제입니다.

### 예시 1
```
높이: [2, 1, 5, 6, 2, 3]

히스토그램 모양:
      6
    5 □
    □ □
    □ □ 3
2   □ □ 2 □
□ 1 □ □ □ □
□ □ □ □ □ □
-----------
0 1 2 3 4 5 (인덱스)

최대 직사각형: 인덱스 2~3 구간에서 높이 5로 만든 직사각형
넓이 = 5 × 2 = 10
```

### 예시 2
```
높이: [2, 4]

히스토그램:
  4
  □
2 □
□ □
---
0 1

최대 직사각형: 전체 구간에서 높이 2로 만든 직사각형
넓이 = 2 × 2 = 4
```

## 핵심 아이디어

### 1. 스택을 사용하는 이유
- 각 막대를 기준으로 **좌우로 확장할 수 있는 최대 범위**를 찾아야 합니다
- 스택은 **단조 증가(monotonic increasing)** 상태를 유지합니다
- 현재 막대가 스택 top보다 낮으면, 스택의 막대들로 직사각형을 만들 수 있습니다

### 2. 알고리즘 원리
1. 스택에는 **인덱스**를 저장합니다 (높이가 아닌 인덱스!)
2. 현재 막대가 스택 top의 막대보다 **높거나 같으면** → 스택에 push
3. 현재 막대가 스택 top의 막대보다 **낮으면** → 직사각형 계산 시작

## 상세한 동작 과정

### 단계별 예시: [2, 1, 5, 6, 2, 3]

#### 초기 상태
```
heights = [2, 1, 5, 6, 2, 3, 0] // 마지막에 0 추가
stack = []
maxArea = 0
```

#### Step 1: i = 0, height = 2
```
스택이 비었으므로 push
stack = [0]
```

#### Step 2: i = 1, height = 1
```
1 < 2 (현재 높이 < 스택 top의 높이)
→ 직사각형 계산!

pop(): heightIndex = 0, h = 2
스택이 비었으므로 w = i = 1
area = 2 × 1 = 2
maxArea = 2

그 후 현재 인덱스 push
stack = [1]
```

#### Step 3: i = 2, height = 5
```
5 > 1 → push
stack = [1, 2]
```

#### Step 4: i = 3, height = 6
```
6 > 5 → push
stack = [1, 2, 3]
```

#### Step 5: i = 4, height = 2
```
2 < 6 → 계산 시작!

첫 번째 pop: heightIndex = 3, h = 6
w = i - stack.top - 1 = 4 - 2 - 1 = 1
area = 6 × 1 = 6
maxArea = 6

2 < 5 → 계속 계산!

두 번째 pop: heightIndex = 2, h = 5
w = i - stack.top - 1 = 4 - 1 - 1 = 2
area = 5 × 2 = 10
maxArea = 10

2 >= 1 → 멈추고 push
stack = [1, 4]
```

#### Step 6: i = 5, height = 3
```
3 > 2 → push
stack = [1, 4, 5]
```

#### Step 7: i = 6, height = 0 (추가한 0)
```
모든 남은 막대 처리

pop: heightIndex = 5, h = 3
w = 6 - 4 - 1 = 1
area = 3 × 1 = 3

pop: heightIndex = 4, h = 2
w = 6 - 1 - 1 = 4
area = 2 × 4 = 8

pop: heightIndex = 1, h = 1
w = 6 (스택이 비었으므로)
area = 1 × 6 = 6

최종 maxArea = 10
```

## 핵심 포인트 정리

### 1. 왜 스택을 사용하나요?
- 각 막대에서 **왼쪽으로 얼마나 확장할 수 있는지** 효율적으로 계산
- 스택에 있는 막대들은 항상 **증가하는 순서**로 유지됨

### 2. 너비 계산 공식
```
if (스택이 비었다면) {
    w = i  // 왼쪽 끝부터 현재 위치까지
} else {
    w = i - stack.top - 1  // 스택 top 다음부터 현재 위치 전까지
}
```

### 3. 왜 마지막에 0을 추가하나요?
- 스택에 남은 모든 막대를 처리하기 위해
- 0은 모든 막대보다 낮으므로 모든 계산을 강제로 수행

## 시간 복잡도
- O(n): 각 막대는 최대 한 번 push, 한 번 pop
- 공간 복잡도: O(n)